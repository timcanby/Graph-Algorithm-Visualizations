<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm: Growing the Minimum Spanning Tree</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #main-container {
            display: flex;
            gap: 20px;
            width: 98%;
            height: 98%;
        }
        #graph-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #graph-container {
            position: relative;
            flex-grow: 1;
            background-color: #1e1e1e;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.6 );
        }
        svg {
            width: 100%;
            height: 100%;
        }
        #controls-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: 2px solid #03dac6;
            border-radius: 8px;
            cursor: pointer;
            background-color: transparent;
            color: #03dac6;
            transition: all 0.3s ease;
        }
        button:hover:not(:disabled) {
            background-color: #03dac6;
            color: #121212;
        }
        button:disabled {
            border-color: #444;
            color: #444;
        }
        #info-panel {
            font-size: 1.1em;
            text-align: right;
        }
        #sidebar {
            flex: 1;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
        }
        #sidebar h2 {
            margin: 0 0 15px 0;
            text-align: center;
            color: #bb86fc;
        }
        #edge-queue {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .edge-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background-color: #373737;
            border-radius: 5px;
            border-left: 5px solid #ff7f0e; /* Orange for frontier */
            transition: all 0.3s ease;
        }
        .edge-item.popped {
            border-left-color: #fdd835; /* Yellow */
            transform: scale(1.05);
            background-color: #444;
        }
        .node circle { stroke: #fff; stroke-width: 2px; transition: all 0.3s ease; }
        .node text { fill: #fff; font-size: 14px; pointer-events: none; text-anchor: middle; dominant-baseline: central; font-weight: bold; }
        .link { stroke: #666; stroke-width: 2px; transition: all 0.3s ease; }
        .link-label { fill: #ccc; font-size: 12px; text-anchor: middle; pointer-events: none; }
        .frontier-edge { stroke: #ff7f0e; stroke-width: 3px; stroke-dasharray: 5 5; }
        .mst-edge { stroke: #03dac6; stroke-width: 5px; stroke-dasharray: 0; }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="graph-panel">
            <div id="graph-container">
                <svg id="svg"></svg>
            </div>
            <div id="controls-info">
                <div class="controls">
                    <button id="startBtn">Start</button>
                    <button id="resetBtn">Reset</button>
                </div>
                <div id="info-panel">Ready to grow the Minimum Spanning Tree.</div>
            </div>
        </div>
        <div id="sidebar">
            <h2>Frontier Edges (Priority Queue)</h2>
            <div id="edge-queue"></div>
        </div>
    </div>

<script>
    // --- D3 Setup & UI ---
    const svg = d3.select("svg");
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const infoPanel = document.getElementById('info-panel');
    const edgeQueueDiv = document.getElementById('edge-queue');

    // --- Config ---
    const NUM_NODES = 25;
    const ANIMATION_SPEED = 600;

    let nodesData, linksData, simulation, adjList;
    let isRunning = false;
    let linkElements, nodeElements, labelElements;
    
    // --- Graph Generation ---
    function generateGraph() {
        const nodes = d3.range(NUM_NODES).map(i => ({ id: i }));
        const links = [];
        const linkSet = new Set();

        for (let i = 1; i < NUM_NODES; i++) {
            const targetId = i;
            const sourceId = Math.floor(Math.random() * i);
            const weight = Math.floor(Math.random() * 20) + 1;
            links.push({ source: nodes[sourceId], target: nodes[targetId], weight });
            linkSet.add(`${sourceId},${targetId}`);
        }

        for (let i = 0; i < NUM_NODES * 1.5; i++) {
            const sourceId = Math.floor(Math.random() * NUM_NODES);
            const targetId = Math.floor(Math.random() * NUM_NODES);
            const key1 = `${sourceId},${targetId}`, key2 = `${targetId},${sourceId}`;
            if (sourceId !== targetId && !linkSet.has(key1) && !linkSet.has(key2)) {
                const weight = Math.floor(Math.random() * 20) + 1;
                links.push({ source: nodes[sourceId], target: nodes[targetId], weight });
                linkSet.add(key1);
            }
        }
        
        const adj = new Map(nodes.map(n => [n.id, []]));
        links.forEach(link => {
            adj.get(link.source.id).push({ node: link.target.id, weight: link.weight });
            adj.get(link.target.id).push({ node: link.source.id, weight: link.weight });
        });

        return { nodes, links, adj };
    }
    
    // --- D3 Drawing ---
    function initializeVisuals() {
        const { clientWidth: width, clientHeight: height } = document.getElementById('graph-container');
        simulation = d3.forceSimulation(nodesData)
            .force("link", d3.forceLink(linksData).id(d => d.id).distance(80).strength(0.6))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        svg.html('');
        const zoomGroup = svg.append("g");

        linkElements = zoomGroup.append("g").selectAll("line").data(linksData).enter().append("line")
            .attr("class", "link")
            .attr("id", d => `link-${Math.min(d.source.id, d.target.id)}-${Math.max(d.source.id, d.target.id)}`);
            
        labelElements = zoomGroup.append("g").selectAll("text").data(linksData).enter().append("text")
            .attr("class", "link-label")
            .text(d => d.weight);
            
        nodeElements = zoomGroup.append("g").selectAll("g").data(nodesData).enter().append("g")
            .attr("class", "node")
            .attr("id", d => `node-${d.id}`);
        
        nodeElements.append("circle").attr("r", 12).attr("fill", "#444"); // Default unexplored color
        nodeElements.append("text").text(d => d.id);

        simulation.on("tick", () => {
            linkElements.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            labelElements.attr("x", d => (d.source.x + d.target.x) / 2).attr("y", d => (d.source.y + d.target.y) / 2);
            nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
        });
    }

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // --- Prim's Algorithm ---
    async function prim() {
        isRunning = true;
        startBtn.disabled = true;
        resetBtn.disabled = true;

        const visited = new Set();
        const pq = []; // Priority Queue for edges
        let mstCost = 0;

        // Start from node 0
        const startNode = 0;
        infoPanel.innerHTML = `Starting MST growth from node <strong>${startNode}</strong>.`;
        await visit(startNode, visited, pq);
        
        while (pq.length > 0 && visited.size < NUM_NODES) {
            pq.sort((a, b) => a.weight - b.weight); // Simulate PQ
            
            updateQueueVisuals(pq);
            await sleep(ANIMATION_SPEED);

            const { u, v, weight } = pq.shift();
            
            const edgeListItem = document.getElementById(`edge-item-${u}-${v}`);
            if(edgeListItem) edgeListItem.classList.add('popped');
            infoPanel.innerHTML = `Choosing cheapest frontier edge (<strong>${u}</strong>, <strong>${v}</strong>) with weight <strong>${weight}</strong>.`;
            
            const linkId = `link-${Math.min(u, v)}-${Math.max(u, v)}`;
            d3.select(`#${linkId}`).classed("mst-edge", true);

            await sleep(ANIMATION_SPEED);

            if (visited.has(v)) {
                infoPanel.innerHTML = `Node <strong>${v}</strong> is already in the tree. Ignoring.`;
                continue;
            }

            mstCost += weight;
            infoPanel.innerHTML = `Node <strong>${v}</strong> joins the tree! Total cost: <strong>${mstCost}</strong>`;
            await visit(v, visited, pq);
        }

        infoPanel.innerHTML = `<strong>Finished!</strong> Minimum Spanning Tree Cost: <strong>${mstCost}</strong>`;
        isRunning = false;
        resetBtn.disabled = false;
    }

    async function visit(u, visited, pq) {
        visited.add(u);
        d3.select(`#node-${u} circle`).transition().attr("fill", "#03dac6").attr("r", 15).transition().attr("r", 12);

        // Add all outgoing edges to the priority queue
        for (const { node: v, weight } of adjList.get(u)) {
            if (!visited.has(v)) {
                pq.push({ u, v, weight });
                const linkId = `link-${Math.min(u, v)}-${Math.max(u, v)}`;
                d3.select(`#${linkId}`).classed("frontier-edge", true);
            }
        }
        // Remove edges that now connect two visited nodes
        pq.forEach(edge => {
            if (visited.has(edge.u) && visited.has(edge.v)) {
                const linkId = `link-${Math.min(edge.u, edge.v)}-${Math.max(edge.u, edge.v)}`;
                d3.select(`#${linkId}`).classed("frontier-edge", false);
            }
        });
    }

    function updateQueueVisuals(pq) {
        pq.sort((a, b) => a.weight - b.weight);
        edgeQueueDiv.innerHTML = '';
        const uniqueEdges = new Map();
        
        // Filter out edges leading to already visited nodes and keep the cheapest one
        pq.forEach(edge => {
            if (!uniqueEdges.has(edge.v) || uniqueEdges.get(edge.v).weight > edge.weight) {
                uniqueEdges.set(edge.v, edge);
            }
        });

        const filteredPq = Array.from(uniqueEdges.values()).sort((a, b) => a.weight - b.weight);

        filteredPq.forEach(({ u, v, weight }) => {
            const div = document.createElement('div');
            div.className = 'edge-item';
            div.id = `edge-item-${u}-${v}`;
            div.innerHTML = `<span>Edge: (${u}, ${v})</span> <span>Weight: ${weight}</span>`;
            edgeQueueDiv.appendChild(div);
        });
    }

    // --- Control Logic ---
    function reset() {
        if (isRunning) return;
        const graph = generateGraph();
        nodesData = graph.nodes;
        linksData = graph.links;
        adjList = graph.adj;
        
        initializeVisuals();
        
        edgeQueueDiv.innerHTML = '';
        infoPanel.textContent = "Ready to grow the Minimum Spanning Tree.";
        startBtn.disabled = false;
        resetBtn.disabled = false;
    }
    
    startBtn.addEventListener('click', () => { if (!isRunning) prim(); });
    resetBtn.addEventListener('click', reset);
    
    // Initial load
    reset();

</script>
</body>
</html>
